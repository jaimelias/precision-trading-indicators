var PrecisionTradingIndicators;(()=>{"use strict";var s={d:(e,t)=>{for(var i in t)s.o(t,i)&&!s.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},o:(s,e)=>Object.prototype.hasOwnProperty.call(s,e),r:s=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(s,"__esModule",{value:!0})}},e={};(()=>{s.r(e),s.d(e,{default:()=>u});const t=(s,e,t)=>{const i=s(2/(t+1)),r=e.length,n=[];if(i.isGreaterThan(1))return Array(r);if(i.isEqualTo(1))return[...e];let l=0,u=0;for(;u<r;u++){const s=e[u];if("object"==typeof s){n[u]=s,l=s,u++;break}}if(Array.isArray(i))for(;u<r;u++){const s=e[u];"object"==typeof s&&"object"==typeof i[u]?l=n[u]=i[u].multipliedBy(s).plus(i[u].minus(1).multipliedBy(l)):n[u]=n[u-1]}else{const t=s(1).minus(i);for(;u<r;u++){const s=e[u];l="object"==typeof s?i.multipliedBy(s).plus(t.multipliedBy(l)):n[u-1],n[u]=l}}return n},i=(s,e,t)=>{const i=e.length,r=e.map((e=>s(e)));if(!t)return r.reduce(((s,e)=>s.plus(e))).dividedBy(i);if(t<=1)return r.slice();if(t>i)return Array(i);const n=[];let l=s(0);for(let s=0;s<i;s++){const e=r[s];if("object"==typeof e&&(l=l.plus(e)),s>=t){const e=r[s-t];"object"==typeof e&&(l=l.minus(e))}s>=t-1&&(n[s]=l.dividedBy(t))}return n},r=(s,e,t,i)=>{const r=Array.isArray(s),n=Array.isArray(e);if(r&&n&&s.length!==e.length)throw new Error("Array lengths must be the same");!r&&n&&(s=Array(e.length).fill(s)),r&&!n&&(e=Array(s.length).fill(e)),r||n||(s=[s],e=[e]);const l=[];for(let r=0;r<s.length;r++){let n;switch(t){case"add":n=i(s[r]).plus(e[r]);break;case"mul":n=i(s[r]).times(e[r]);break;case"sub":n=i(s[r]).minus(e[r]);break;case"div":n=i(s[r]).dividedBy(e[r]);break;default:throw new Error("Invalid operation")}l.push(n)}return l},n=({fast:s,slow:e})=>{const t=s.length;let i=null,r=null,n=t-1;for(;n>=0&&null===i;)s[n].isLessThan(e[n])&&n>0&&s[n-1].isGreaterThanOrEqualTo(e[n-1])?(i="death",r=n):s[n].isGreaterThan(e[n])&&n>0&&s[n-1].isLessThanOrEqualTo(e[n-1])&&(i="golden",r=n),n--;return null===i?{crossInterval:null,crossType:null}:{crossInterval:r<t-1?t-1-r:0,crossType:i}},l=(s,e)=>{let{upper:t,lower:i,mid:r}=e;t=t[t.length-1],i=i[i.length-1],r=r[r.length-1];const n=t.minus(i);return s.minus(i).dividedBy(n).times(100)};class u{constructor(s){this.BigNumber=s,this.EMA=this.EMA.bind(this),this.MA=this.MA.bind(this),this.MACD=this.MACD.bind(this),this.BOLLINGER_BANDS=this.BOLLINGER_BANDS.bind(this),this.ADX=this.ADX.bind(this),this.MFI=this.MFI.bind(this),this.RSI=this.RSI.bind(this),this.STOCHASTIC_RSI=this.STOCHASTIC_RSI.bind(this),this.bollingerBandsLocation=this.bollingerBandsLocation.bind(this),this.getTrend=this.getTrend.bind(this),this.findLastCross=this.findLastCross.bind(this)}EMA(s,e){return t(this.BigNumber,s,e)}MA(s,e){return i(this.BigNumber,s,e)}MACD(s,e=12,i=26,l=9){return((s,e,i=12,l=26,u=9)=>{const o=t(s,e,i),d=t(s,e,l),h=r(o,d,"sub",s),a=t(s,h,u),c=r(s(2),r(h,a,"sub",s),"mul",s),{crossType:p,crossInterval:m}=n({fast:h,slow:a});return{diff:h,dea:a,histogram:c,crossType:p,crossInterval:m}})(this.BigNumber,s,12,26,9)}BOLLINGER_BANDS(s,e,t){return((s,e,t=20,n=2)=>{n=s(n);const u=i(s,e,t),o=((s,e,t)=>{const r=s(0),n=e.length,l=i(s,e,t),u=[];let o,d,h=t-1;for(;h<n;h++){for(d=r,o=h-t+1;o<=h;o++)d=d.plus(e[o].minus(l[h]).pow(2));u[h]=d.dividedBy(t).sqrt()}return u})(s,e,t),d=r(o,n,"mul",s);let h=r(u,d,"add",s),a=u,c=r(u,d,"sub",s);const p=e[e.length-1];return{upper:h,mid:a,lower:c,loc:l(p,{upper:h,mid:a,lower:c})}})(this.BigNumber,s,e,t)}ADX(s,e){return((s,e,t=14)=>{let{high:i,low:r,close:n}=e;const l=s(0),u=s(100),o=s=>s.reduce(((s,e)=>s.plus(e)),l),d=[],h=[],a=[],c=[],p=[],m=[],y=[],f=[];let g=[];const b=[];for(let e=1;e<i.length;e++){const t=i[e].minus(i[e-1]),u=r[e-1].minus(r[e]),o=t.isGreaterThan(u)&&t.isGreaterThan(0)?t:l,c=u.isGreaterThan(t)&&u.isGreaterThan(0)?u:l,p=s.max(i[e].minus(r[e]),i[e].minus(n[e-1]).abs(),r[e].minus(n[e-1]).abs());d.push(o),h.push(c),a.push(p)}const B=o(d.slice(0,t)).dividedBy(t),v=o(h.slice(0,t)).dividedBy(t),T=o(a.slice(0,t)).dividedBy(t);c.push(B),p.push(v),m.push(T);for(let s=t;s<i.length;s++){const e=c[s-t].times(t-1).plus(d[s]).dividedBy(t),i=p[s-t].times(t-1).plus(h[s]).dividedBy(t),r=m[s-t].times(t-1).plus(a[s]).dividedBy(t);c.push(e),p.push(i),m.push(r)}for(let s=0;s<c.length;s++){const e=u.times(c[s].dividedBy(m[s])),t=u.times(p[s].dividedBy(m[s]));y.push(e),f.push(t)}for(let s=t;s<c.length;s++){const e=y.slice(s-t+1,s+1).reduce(((s,e)=>s.plus(e))),i=f.slice(s-t+1,s+1).reduce(((s,e)=>s.plus(e))),r=u.times(e.minus(i).abs().div(e.plus(i)));g.push(r)}g.length>=2*t-1&&(g=g.filter((s=>!isNaN(s))));const A=g.slice(0,t).reduce(((s,e)=>s.plus(e))).div(t);b.push(A);for(let s=t;s<g.length;s++){const e=b[s-t].times(t-1).plus(g[s]).div(t);b.push(e)}return b})(this.BigNumber,s,e)}MFI(s,e){return((s,e,t=14)=>{const{high:i,low:r,close:n,volume:l}=e,u=s(0),o=s(100),d=s(1),h=[],a=[],c=[],p=[],m=[],y=[];for(let s=0;s<n.length;s++){const e=i[s].plus(r[s]).plus(n[s]).dividedBy(3),t=e.times(l[s]);h.push(e),a.push(t)}for(let s=1;s<h.length;s++)h[s].isGreaterThan(h[s-1])?(c.push(a[s]),p.push(u)):h[s].isLessThan(h[s-1])?(c.push(u),p.push(a[s])):(c.push(u),p.push(u));for(let s=t;s<=c.length;s++){const e=c.slice(s-t,s),i=p.slice(s-t,s),r=e.reduce(((s,e)=>s.plus(e)),u),n=i.reduce(((s,e)=>s.plus(e)),u),l=r.dividedBy(n);m.push(l)}for(let s=0;s<m.length;s++){const e=o.minus(o.dividedBy(d.plus(m[s])));y.push(e)}return y})(this.BigNumber,s,e)}RSI(s,e){return((s,e,t)=>{if(e.length<t)return[];let i=[],r=e.slice(0,t);const n=s(0),l=s(100),u=s(1);for(let o=t,d=n,h=n;o<e.length;o++,d=n,h=n){r.push(e[o]);for(let e=1;e<r.length;e++){const t=s(r[e]),i=s(r[e-1]);t.minus(i).isLessThan(n)?h=h.plus(t.minus(i).abs()):d=d.plus(t.minus(i))}const a=d.dividedBy(t),c=h.dividedBy(t),p=c.isEqualTo(n)?n:a.dividedBy(c),m=l.minus(l.dividedBy(u.plus(p)));i.push(m),r.splice(0,1)}return i})(this.BigNumber,s,e)}STOCHASTIC_RSI(s,e,i,r){return((s,e,i,r,l)=>{if(e.length<i)return[];const u=s.max(i,r,l),o=[];for(let t=u.toNumber();t<e.length;t++){const i=e.slice(t-u.toNumber(),t+1),r=s.min(...i),n=s.max(...i),l=e[t].minus(r).dividedBy(n.minus(r)).times(100);o.push(l)}const d=t(s,o,r),h=t(s,d,l),{crossType:a,crossInterval:c}=n({fast:d,slow:h});return{K:d,D:h,crossType:a,crossInterval:c}})(this.BigNumber,s,e,i,r)}bollingerBandsLocation(s,e){return l(s,e)}getTrend(s,e){return((s,e,t)=>{const i=e.length,r=Math.max(0,i-t),n=i-1;let l="";const u=s(0),o=s(.5),d=new Array(n-r);for(let s=r;s<n;s++)d[s-r]=e[s+1].minus(e[s]);const h=d.reduce(((s,e)=>s.plus(e)),u).dividedBy(d.length),a=d.reduce(((s,e)=>s.plus(e.minus(h).pow(2))),u).dividedBy(d.length-1).sqrt();return l=h.isGreaterThan(u)&&a.isGreaterThan(o.times(h))?"upward":h.isLessThan(u)&&a.isGreaterThan(o.times(h.abs()))?"downward":"sideward",l})(this.BigNumber,s,e)}findLastCross({fast:s,slow:e}){return n({fast:s,slow:e})}}})(),PrecisionTradingIndicators=e})();