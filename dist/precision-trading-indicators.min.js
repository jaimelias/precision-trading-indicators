var PrecisionTradingIndicators;(()=>{"use strict";var e={d:(s,t)=>{for(var i in t)e.o(t,i)&&!e.o(s,i)&&Object.defineProperty(s,i,{enumerable:!0,get:t[i]})},o:(e,s)=>Object.prototype.hasOwnProperty.call(e,s),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},s={};(()=>{e.r(s),e.d(s,{default:()=>u});const t=(e,s,t)=>{const i=e(2/(t+1)),r=s.length,n=[];if(i.isGreaterThan(1))return Array(r);if(i.isEqualTo(1))return[...s];let l=0,u=0;for(;u<r;u++){const e=s[u];if("object"==typeof e){n[u]=e,l=e,u++;break}}if(Array.isArray(i))for(;u<r;u++){const e=s[u];"object"==typeof e&&"object"==typeof i[u]?l=n[u]=i[u].multipliedBy(e).plus(i[u].minus(1).multipliedBy(l)):n[u]=n[u-1]}else{const t=e(1).minus(i);for(;u<r;u++){const e=s[u];l="object"==typeof e?i.multipliedBy(e).plus(t.multipliedBy(l)):n[u-1],n[u]=l}}return n},i=(e,s,t)=>{const i=s.length,r=s.map((s=>e(s)));if(!t)return r.reduce(((e,s)=>e.plus(s))).dividedBy(i);if(t<=1)return r.slice();if(t>i)return Array(i);const n=[];let l=e(0);for(let e=0;e<i;e++){const s=r[e];if("object"==typeof s&&(l=l.plus(s)),e>=t){const s=r[e-t];"object"==typeof s&&(l=l.minus(s))}e>=t-1&&(n[e]=l.dividedBy(t))}return n},r=(e,s,t,i)=>{const r=Array.isArray(e),n=Array.isArray(s);if(r&&n&&e.length!==s.length)throw new Error("Array lengths must be the same");!r&&n&&(e=Array(s.length).fill(e)),r&&!n&&(s=Array(e.length).fill(s)),r||n||(e=[e],s=[s]);const l=[];for(let r=0;r<e.length;r++){let n;switch(t){case"add":n=i(e[r]).plus(s[r]);break;case"mul":n=i(e[r]).times(s[r]);break;case"sub":n=i(e[r]).minus(s[r]);break;case"div":n=i(e[r]).dividedBy(s[r]);break;default:throw new Error("Invalid operation")}l.push(n)}return l},n=({fast:e,slow:s})=>{const t=e.length;let i=null,r=null,n=t-1;for(;n>=0&&null===i;)e[n].isLessThan(s[n])&&n>0&&e[n-1].isGreaterThanOrEqualTo(s[n-1])?(i="down",r=n):e[n].isGreaterThan(s[n])&&n>0&&e[n-1].isLessThanOrEqualTo(s[n-1])&&(i="up",r=n),n--;return null===i?{crossInterval:null,crossType:null}:{crossInterval:r<t-1?t-1-r:0,crossType:i}},l=(e,s)=>{let{upper:t,lower:i,mid:r}=s;t=t[t.length-1],i=i[i.length-1],r=r[r.length-1];const n=t.minus(i);return e.minus(i).dividedBy(n).times(100)};class u{constructor(e){this.BigNumber=e,this.EMA=this.EMA.bind(this),this.MA=this.MA.bind(this),this.MACD=this.MACD.bind(this),this.BOLLINGER_BANDS=this.BOLLINGER_BANDS.bind(this),this.ADX=this.ADX.bind(this),this.MFI=this.MFI.bind(this),this.RSI=this.RSI.bind(this),this.STOCHASTIC_RSI=this.STOCHASTIC_RSI.bind(this),this.bollingerBandsLocation=this.bollingerBandsLocation.bind(this),this.getTrend=this.getTrend.bind(this),this.findLastCross=this.findLastCross.bind(this),this.getMomentum=this.getMomentum.bind(this)}EMA(e,s){return t(this.BigNumber,e,s)}MA(e,s){return i(this.BigNumber,e,s)}MACD(e,s,i,l){return((e,s,i=12,l=26,u=9)=>{const o=t(e,s,i),d=t(e,s,l),h=r(o,d,"sub",e),a=t(e,h,u),c=r(e(2),r(h,a,"sub",e),"mul",e),{crossType:p,crossInterval:m}=n({fast:h,slow:a});return{diff:h,dea:a,histogram:c,crossType:p,crossInterval:m}})(this.BigNumber,e,s,i,l)}BOLLINGER_BANDS(e,s,t){return((e,s,t=20,n=2)=>{n=e(n);const u=i(e,s,t),o=((e,s,t)=>{const r=e(0),n=s.length,l=i(e,s,t),u=[];let o,d,h=t-1;for(;h<n;h++){for(d=r,o=h-t+1;o<=h;o++)d=d.plus(s[o].minus(l[h]).pow(2));u[h]=d.dividedBy(t).sqrt()}return u})(e,s,t),d=r(o,n,"mul",e);let h=r(u,d,"add",e),a=u,c=r(u,d,"sub",e);const p=s[s.length-1];return{upper:h,mid:a,lower:c,loc:l(p,{upper:h,mid:a,lower:c})}})(this.BigNumber,e,s,t)}ADX(e,s){return((e,s,t=14)=>{let{high:i,low:r,close:n}=s;const l=e(0),u=e(100),o=e=>e.reduce(((e,s)=>e.plus(s)),l),d=[],h=[],a=[],c=[],p=[],m=[],g=[],f=[];let y=[];const b=[];for(let s=1;s<i.length;s++){const t=i[s].minus(i[s-1]),u=r[s-1].minus(r[s]),o=t.isGreaterThan(u)&&t.isGreaterThan(0)?t:l,c=u.isGreaterThan(t)&&u.isGreaterThan(0)?u:l,p=e.max(i[s].minus(r[s]),i[s].minus(n[s-1]).abs(),r[s].minus(n[s-1]).abs());d.push(o),h.push(c),a.push(p)}const B=o(d.slice(0,t)).dividedBy(t),T=o(h.slice(0,t)).dividedBy(t),v=o(a.slice(0,t)).dividedBy(t);c.push(B),p.push(T),m.push(v);for(let e=t;e<i.length;e++){const s=c[e-t].times(t-1).plus(d[e]).dividedBy(t),i=p[e-t].times(t-1).plus(h[e]).dividedBy(t),r=m[e-t].times(t-1).plus(a[e]).dividedBy(t);c.push(s),p.push(i),m.push(r)}for(let e=0;e<c.length;e++){const s=u.times(c[e].dividedBy(m[e])),t=u.times(p[e].dividedBy(m[e]));g.push(s),f.push(t)}for(let e=t;e<c.length;e++){const s=g.slice(e-t+1,e+1).reduce(((e,s)=>e.plus(s))),i=f.slice(e-t+1,e+1).reduce(((e,s)=>e.plus(s))),r=u.times(s.minus(i).abs().div(s.plus(i)));y.push(r)}y.length>=2*t-1&&(y=y.filter((e=>!isNaN(e))));const A=y.slice(0,t).reduce(((e,s)=>e.plus(s))).div(t);b.push(A);for(let e=t;e<y.length;e++){const s=b[e-t].times(t-1).plus(y[e]).div(t);b.push(s)}return b})(this.BigNumber,e,s)}MFI(e,s){return((e,s,t=14)=>{const{high:i,low:r,close:n,volume:l}=s,u=e(0),o=e(100),d=e(1),h=[],a=[],c=[],p=[],m=[],g=[];for(let e=0;e<n.length;e++){const s=i[e].plus(r[e]).plus(n[e]).dividedBy(3),t=s.times(l[e]);h.push(s),a.push(t)}for(let e=1;e<h.length;e++)h[e].isGreaterThan(h[e-1])?(c.push(a[e]),p.push(u)):h[e].isLessThan(h[e-1])?(c.push(u),p.push(a[e])):(c.push(u),p.push(u));for(let e=t;e<=c.length;e++){const s=c.slice(e-t,e),i=p.slice(e-t,e),r=s.reduce(((e,s)=>e.plus(s)),u),n=i.reduce(((e,s)=>e.plus(s)),u),l=r.dividedBy(n);m.push(l)}for(let e=0;e<m.length;e++){const s=o.minus(o.dividedBy(d.plus(m[e])));g.push(s)}return g})(this.BigNumber,e,s)}RSI(e,s){return((e,s,t=14)=>{if(s.length<t)return[];let i=[],r=s.slice(0,t);const n=e(0),l=e(100),u=e(1);for(let o=t,d=n,h=n;o<s.length;o++,d=n,h=n){r.push(s[o]);for(let s=1;s<r.length;s++){const t=e(r[s]),i=e(r[s-1]);t.minus(i).isLessThan(n)?h=h.plus(t.minus(i).abs()):d=d.plus(t.minus(i))}const a=d.dividedBy(t),c=h.dividedBy(t),p=c.isEqualTo(n)?n:a.dividedBy(c),m=l.minus(l.dividedBy(u.plus(p)));i.push(m),r.splice(0,1)}return i})(this.BigNumber,e,s)}STOCHASTIC_RSI(e,s,i,r){return((e,s,i=14,r=3,l=3)=>{if(s.length<i)return[];const u=e.max(i,r,l),o=[];for(let t=u.toNumber();t<s.length;t++){const i=s.slice(t-u.toNumber(),t+1),r=e.min(...i),n=e.max(...i),l=s[t].minus(r).dividedBy(n.minus(r)).times(100);o.push(l)}const d=t(e,o,r),h=t(e,d,l),{crossType:a,crossInterval:c}=n({fast:h,slow:d});return{K:d,D:h,crossType:a,crossInterval:c}})(this.BigNumber,e,s,i,r)}bollingerBandsLocation(e,s){return l(e,s)}getTrend(e,s){return((e,s,t=24)=>{const i=s.length,r=Math.max(0,i-t),n=i-1;let l="";const u=e(0),o=e(.5),d=new Array(n-r);for(let e=r;e<n;e++)d[e-r]=s[e+1].minus(s[e]);const h=d.reduce(((e,s)=>e.plus(s)),u).dividedBy(d.length),a=d.reduce(((e,s)=>e.plus(s.minus(h).pow(2))),u).dividedBy(d.length-1).sqrt();return l=h.isGreaterThan(u)&&a.isGreaterThan(o.times(h))?"up":h.isLessThan(u)&&a.isGreaterThan(o.times(h.abs()))?"down":"neutral",l})(this.BigNumber,e,s)}findLastCross({fast:e,slow:s}){return n({fast:e,slow:s})}getMomentum({data:e,fast:s,slow:t,threshold:i}){return(({data:e,fast:s,slow:t,threshold:i=.02})=>{const r=e[e.length-1].minus(s[s.length-1]),n=s[s.length-1].minus(t[t.length-1]),l=s[s.length-1];if(r.isGreaterThan(0)&&n.isGreaterThan(0)){const e=r.dividedBy(l),s=n.dividedBy(l);return e.isGreaterThan(i)&&s.isGreaterThan(i)?"strong up":"up"}if(r.isLessThan(0)&&n.isLessThan(0)){const e=r.abs().dividedBy(l),s=n.abs().dividedBy(l);return e.isGreaterThan(i)&&s.isGreaterThan(i)?"strong down":"down"}return"neutral"})({data:e,fast:s,slow:t,threshold:i})}}})(),PrecisionTradingIndicators=s})();