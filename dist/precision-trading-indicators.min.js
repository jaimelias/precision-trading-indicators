var PrecisionTradingIndicators;(()=>{"use strict";var e={d:(s,t)=>{for(var i in t)e.o(t,i)&&!e.o(s,i)&&Object.defineProperty(s,i,{enumerable:!0,get:t[i]})},o:(e,s)=>Object.prototype.hasOwnProperty.call(e,s),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},s={};(()=>{e.r(s),e.d(s,{default:()=>u});const t=(e,s,t)=>{const i=e(2/(t+1)),n=s.length,r=[];if(i.isGreaterThan(1))return Array(n);if(i.isEqualTo(1))return[...s];let o=0,l=0;for(;l<n;l++){const e=s[l];if("object"==typeof e){r[l]=e,o=e,l++;break}}if(Array.isArray(i))for(;l<n;l++){const e=s[l];"object"==typeof e&&"object"==typeof i[l]?o=r[l]=i[l].multipliedBy(e).plus(i[l].minus(1).multipliedBy(o)):r[l]=r[l-1]}else{const t=e(1).minus(i);for(;l<n;l++){const e=s[l];o="object"==typeof e?i.multipliedBy(e).plus(t.multipliedBy(o)):r[l-1],r[l]=o}}return r},i=(e,s,t)=>{let i=[],n=e(0),r=[];for(let e=0;e<s.length;e++)r.push(s[e]),n=n.plus(s[e]),r.length>t&&(n=n.minus(r.shift())),e>=t-1?i.push(n.dividedBy(t)):i.push(n.dividedBy(r.length));return i},n=(e,s,t,i)=>{const n=Array.isArray(e),r=Array.isArray(s);if(n&&r&&e.length!==s.length)throw new Error("Array lengths must be the same");!n&&r&&(e=Array(s.length).fill(e)),n&&!r&&(s=Array(e.length).fill(s)),n||r||(e=[e],s=[s]);const o=[];for(let n=0;n<e.length;n++){let r;switch(t){case"add":r=i(e[n]).plus(s[n]);break;case"mul":r=i(e[n]).times(s[n]);break;case"sub":r=i(e[n]).minus(s[n]);break;case"div":r=i(e[n]).dividedBy(s[n]);break;default:throw new Error("Invalid operation")}o.push(r)}return o},r=({fast:e,slow:s})=>{let t=Math.min(e.length,s.length);for(;e.length>t;)e.shift();for(;s.length>t;)s.shift();let i=null,n=null,r=t-1;for(;r>=0&&null===i;)e[r].isLessThan(s[r])&&r>0&&e[r-1].isGreaterThanOrEqualTo(s[r-1])?(i="down",n=r):e[r].isGreaterThan(s[r])&&r>0&&e[r-1].isLessThanOrEqualTo(s[r-1])&&(i="up",n=r),r--;return null===i?{crossInterval:null,crossType:null}:{crossInterval:n<t-1?t-1-n:0,crossType:i}},o=(e,s)=>{let{upper:t,lower:i,mid:n}=s;t=t[t.length-1],i=i[i.length-1],n=n[n.length-1];const r=t.minus(i);return e.minus(i).dividedBy(r).times(100)},l=(e,s,t,i)=>{let n=[];for(let r=i-1;r<s.length;r++){let o=new e(0);for(let e=r;e>r-i;e--){const i=s[e].plus(t[e]).dividedBy(2);o=o.plus(i)}n.push(o.dividedBy(i))}return n};class u{constructor(e){this.BigNumber=e,this.EMA=this.EMA.bind(this),this.MA=this.MA.bind(this),this.MACD=this.MACD.bind(this),this.BOLLINGER_BANDS=this.BOLLINGER_BANDS.bind(this),this.ICHIMOKU_CLOUD=this.ICHIMOKU_CLOUD.bind(this),this.ADX=this.ADX.bind(this),this.MFI=this.MFI.bind(this),this.RSI=this.RSI.bind(this),this.STOCHASTIC_RSI=this.STOCHASTIC_RSI.bind(this),this.bollingerBandsLocation=this.bollingerBandsLocation.bind(this),this.findLastCross=this.findLastCross.bind(this),this.getMomentum=this.getMomentum.bind(this),this.linearRegression=this.linearRegression.bind(this)}EMA(e,s){return t(this.BigNumber,e,s)}MA(e,s){return i(this.BigNumber,e,s)}MACD(e,s,i,o){return((e,s,i=12,o=26,l=9)=>{const u=t(e,s,i),a=t(e,s,o),d=n(u,a,"sub",e),h=t(e,d,l),c=n(e(2),n(d,h,"sub",e),"mul",e),{crossType:m,crossInterval:p}=r({fast:d,slow:h});return{diff:d,dea:h,histogram:c,crossType:m,crossInterval:p}})(this.BigNumber,e,s,i,o)}BOLLINGER_BANDS(e,s,t){return((e,s,t=20,r=2)=>{r=e(r);const l=i(e,s,t),u=((e,s,t)=>{const n=e(0),r=s.length,o=i(e,s,t),l=[];let u,a,d=t-1;for(;d<r;d++){for(a=n,u=d-t+1;u<=d;u++)a=a.plus(s[u].minus(o[d]).pow(2));l[d]=a.dividedBy(t).sqrt()}return l})(e,s,t),a=n(u,r,"mul",e);let d=n(l,a,"add",e),h=l,c=n(l,a,"sub",e);const m=s[s.length-1];return{upper:d,mid:h,lower:c,loc:o(m,{upper:d,mid:h,lower:c})}})(this.BigNumber,e,s,t)}ICHIMOKU_CLOUD(e){return((e,s)=>{let{high:t,low:i,close:n}=s,o=l(e,t,i,9),u=l(e,t,i,26),a=((e,s,t,i)=>{let n=[];for(let r=0;r<s.length;r++)if(r>=i-1){let o=new e(0);for(let e=r;e>r-i;e--){const i=s[e].plus(t[e]).dividedBy(2);o=o.plus(i)}n.push(o.dividedBy(i))}else n.push(null);return n})(e,o,u,17.5),d=((e,s,t,i)=>{let n=[];for(let r=i-1;r<s.length;r++){let o=new e.maximum(...s.slice(r-i+1,r+1)),l=new e.minimum(...t.slice(r-i+1,r+1));n.push(o.plus(l).dividedBy(2))}return n})(e,t,i,52),h=((e,s)=>e.slice(s))(n,26);o=o.slice(26),u=u.slice(26),a=a.slice(26).filter((e=>e&&!isNaN(e))),h=h.slice(0,-26);const c=n.splice(-a.length);return{conversionLine:o,baseLine:u,leadingSpanA:a,leadingSpanB:d,laggingSpan:h,crosses:{spanACross:r({fast:c,slow:a}),spanBCross:r({fast:c,slow:d}),baseCross:r({fast:o,slow:u})}}})(this.BigNumber,e)}ADX(e,s){return((e,s,t=14)=>{let{high:i,low:n,close:r}=s;const o=e(0),l=e(100),u=i.length,a=e=>e.reduce(((e,s)=>e.plus(s)),o),d=[],h=[],c=[],m=[],p=[],g=[],f=[],b=[],y=[],B=[];for(let s=1;s<u;s++){const l=i[s].minus(i[s-1]),u=n[s-1].minus(n[s]),f=l.isGreaterThan(u)&&l.isGreaterThan(0)?l:o,b=u.isGreaterThan(l)&&u.isGreaterThan(0)?u:o,y=e.max(i[s].minus(n[s]),i[s].minus(r[s-1]).abs(),n[s].minus(r[s-1]).abs());if(d.push(f),h.push(b),c.push(y),s>=t){const e=a(d.slice(s-t,s)).dividedBy(t),i=a(h.slice(s-t,s)).dividedBy(t),n=a(c.slice(s-t,s)).dividedBy(t);m.push(e),p.push(i),g.push(n)}}for(let e=0;e<m.length;e++){const s=l.times(m[e].dividedBy(g[e])),t=l.times(p[e].dividedBy(g[e]));f.push(s),b.push(t)}for(let e=t;e<m.length;e++){const s=a(f.slice(e-t+1,e+1)),i=a(b.slice(e-t+1,e+1)),n=l.times(s.minus(i).abs().div(s.plus(i)));y.push(n)}const v=y.filter((e=>!isNaN(e)));if(v.length>=t-1){const e=a(v.slice(0,t-1)).div(t-1);B.push(e);for(let e=t-1;e<v.length;e++){const s=B[e-t+1].times(t-1).plus(v[e]).div(t);B.push(s)}}return{adx:B,diMinus:b,diPlus:f}})(this.BigNumber,e,s)}MFI(e,s){return((e,s,t=14)=>{const{high:i,low:n,close:r,volume:o}=s,l=e(0),u=e(100),a=e(1),d=[],h=[],c=[],m=[],p=[],g=[];for(let e=0;e<r.length;e++){const s=i[e].plus(n[e]).plus(r[e]).dividedBy(3),t=s.times(o[e]);d.push(s),h.push(t)}for(let e=1;e<d.length;e++)d[e].isGreaterThan(d[e-1])?(c.push(h[e]),m.push(l)):d[e].isLessThan(d[e-1])?(c.push(l),m.push(h[e])):(c.push(l),m.push(l));for(let e=t;e<=c.length;e++){const s=c.slice(e-t,e),i=m.slice(e-t,e),n=s.reduce(((e,s)=>e.plus(s)),l),r=i.reduce(((e,s)=>e.plus(s)),l),o=n.dividedBy(r);p.push(o)}for(let e=0;e<p.length;e++){const s=u.minus(u.dividedBy(a.plus(p[e])));g.push(s)}return g})(this.BigNumber,e,s)}RSI(e,s,i){return((e,s,i=14,n=14)=>{if(s.length<i)return[];let o=[],l=s.slice(0,i);const u=e(0),a=e(100),d=e(1);for(let t=i,n=u,r=u;t<s.length;t++,n=u,r=u){l.push(s[t]);for(let s=1;s<l.length;s++){const t=e(l[s]),i=e(l[s-1]);t.minus(i).isLessThan(u)?r=r.plus(t.minus(i).abs()):n=n.plus(t.minus(i))}const h=n.dividedBy(i),c=r.dividedBy(i),m=c.isEqualTo(u)?u:h.dividedBy(c);o.push(a.minus(a.dividedBy(d.plus(m)))),l.splice(0,1)}const h=t(e,o,n),{crossType:c,crossInterval:m}=r({fast:o,slow:h});return{rsi:o,rsiEma:h,crossType:c,crossInterval:m}})(this.BigNumber,e,s,i)}STOCHASTIC_RSI(e,s,i,n){return((e,s,i=14,n=3,o=3)=>{if(s.length<i)return[];const l=e.max(i,n,o),u=[];for(let t=l.toNumber();t<s.length;t++){const i=s.slice(t-l.toNumber(),t+1),n=e.min(...i),r=e.max(...i),o=s[t].minus(n).dividedBy(r.minus(n)).times(100);u.push(o)}const a=t(e,u,n),d=t(e,a,o),{crossType:h,crossInterval:c}=r({fast:d,slow:a});return{K:a,D:d,crossType:h,crossInterval:c}})(this.BigNumber,e,s,i,n)}bollingerBandsLocation(e,s){return o(e,s)}findLastCross({fast:e,slow:s}){return r({fast:e,slow:s})}getMomentum({data:e,close:s,fast:t,slow:i}){return(({BigNumber:e,close:s,fast:t,slow:i})=>{const n=t[t.length-1],r=i[i.length-1],o=s[s.length-1];return o.isLessThan(n)||o.isLessThan(r)?e(0):n.minus(r).dividedBy(r).multipliedBy(100)})({BigNumber:this.BigNumber,data:e,close:s,fast:t,slow:i})}getCandlestickPattern(e){return(({open:e,high:s,low:t,close:i})=>{if(![e,s,t,i].every((e=>Array.isArray(e)&&e.length>1)))return{pattern:"",name:"",score:0};const n=e.length-2,r=e.length-1,o=e[n].toNumber(),l=s[n].toNumber(),u=t[n].toNumber(),a=i[n].toNumber(),d=e[r].toNumber(),h=s[r].toNumber(),c=t[r].toNumber(),m=i[r].toNumber(),p={bullish:[{name:"Engulfing",condition:c<u&&h>l,score:2},{name:"Piercing Line",condition:m>a&&d<o&&m>(o+a)/2,score:1},{name:"Morning Star",condition:m>a&&d<o&&a<o,score:2},{name:"Harami",condition:m<o&&d>a&&m<a&&d>o,score:1},{name:"Doji",condition:Math.abs(m-d)<.01*m,score:0},{name:"Marubozu",condition:Math.abs(m-d)>.99*m,score:3},{name:"Belt Hold",condition:d>o&&m===h&&a===u,score:1},{name:"Kicker",condition:d<o&&m<a&&m<d,score:2}],bearish:[{name:"Engulfing",condition:h>l&&c<u,score:-2},{name:"Dark Cloud Cover",condition:m<a&&d>o&&m<(o+a)/2,score:-1},{name:"Evening Star",condition:m<a&&d>o&&a<o,score:-2},{name:"Harami",condition:m>o&&d<a&&m>a&&d<o,score:-1},{name:"Doji",condition:Math.abs(m-d)<.01*m,score:0},{name:"Marubozu",condition:Math.abs(m-d)>.99*m,score:-3},{name:"Belt Hold",condition:d<o&&m===c&&a===l,score:-1},{name:"Kicker",condition:d>o&&m>a&&m>d,score:-2}]};for(const e of["bullish","bearish"])for(const{name:s,condition:t,score:i}of p[e])if(t)return{pattern:e,name:s,score:i};return{pattern:"",name:"",score:0}})(e)}linearRegression(e,s){return((e,s,t)=>{const i=new e(0),n=new e(s.length),r=s.reduce(((s,t,i)=>(i=new e(i),{sumX:s.sumX.plus(i),sumY:s.sumY.plus(t),sumXY:s.sumXY.plus(i.multipliedBy(t)),sumX2:s.sumX2.plus(i.multipliedBy(i))})),{sumX:i,sumY:i,sumXY:i,sumX2:i}),o=n.multipliedBy(r.sumXY).minus(r.sumX.multipliedBy(r.sumY)).dividedBy(n.multipliedBy(r.sumX2).minus(r.sumX.multipliedBy(r.sumX))),l=r.sumY.minus(o.multipliedBy(r.sumX)).dividedBy(n),u=[];for(let s=0;s<t;s++){const t=new e(n.plus(s));u.push(o.multipliedBy(t).plus(l))}return u})(this.BigNumber,e,s)}}})(),PrecisionTradingIndicators=s})();