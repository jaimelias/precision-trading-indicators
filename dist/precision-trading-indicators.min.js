var PrecisionTradingIndicators;(()=>{"use strict";var s={d:(i,t)=>{for(var e in t)s.o(t,e)&&!s.o(i,e)&&Object.defineProperty(i,e,{enumerable:!0,get:t[e]})},o:(s,i)=>Object.prototype.hasOwnProperty.call(s,i),r:s=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(s,"__esModule",{value:!0})}},i={};(()=>{s.r(i),s.d(i,{default:()=>m});class t{constructor(s,i,t){this.BigNumber=s,this.size=t,this.alpha=s(2/(t+1)),this.data=i,this.result=[],this.s=null,this.alpha.isGreaterThan(1)?this.result=Array(i.length).fill(null):this.alpha.isEqualTo(1)?this.result=[...i]:this.calculateInitialEMA()}calculateInitialEMA(){const s=this.data.length;let i=0;for(;i<s;){const s=this.data[i];if("object"==typeof s){this.result[i]=s,this.s=s,i++;break}i++}const t=this.BigNumber(1).minus(this.alpha);for(;i<s;i++){const s=this.data[i];this.s="object"==typeof s?this.alpha.multipliedBy(s).plus(t.multipliedBy(this.s)):this.result[i-1],this.result[i]=this.s}}add(s){if(0===this.result.length)this.s=s,this.result.push(s);else{const i=this.BigNumber(1).minus(this.alpha);this.s=this.alpha.multipliedBy(s).plus(i.multipliedBy(this.s)),this.result.push(this.s)}}update(s){if(this.result.length>0){const i=this.BigNumber(1).minus(this.alpha);1===this.result.length?(this.s=s,this.result[0]=s):(this.s=this.alpha.multipliedBy(s).plus(i.multipliedBy(this.result[this.result.length-2])),this.result[this.result.length-1]=this.s)}}get(){return this.result}}class e{constructor(s,i,t){this.BigNumber=s,this.size=t,this.arr=[],this.sum=s(0),this.result=[],i.forEach((s=>{this.add(s)}))}add(s){this.arr.push(s),this.sum=this.sum.plus(s),this.arr.length>this.size&&(this.sum=this.sum.minus(this.arr.shift())),this.arr.length>=this.size?this.result.push(this.sum.dividedBy(this.size)):this.result.push(this.sum.dividedBy(this.arr.length))}update(s){this.arr.length>0&&(this.sum=this.sum.minus(this.arr[this.arr.length-1]),this.arr[this.arr.length-1]=s,this.sum=this.sum.plus(s),this.arr.length>=this.size?this.result[this.result.length-1]=this.sum.dividedBy(this.size):this.result[this.result.length-1]=this.sum.dividedBy(this.arr.length))}get(){return this.result}}const h=(s,i,t,e)=>{const h=Array.isArray(s),n=Array.isArray(i);if(h&&n&&s.length!==i.length)throw new Error("Array lengths must be the same");!h&&n&&(s=Array(i.length).fill(s)),h&&!n&&(i=Array(s.length).fill(i)),h||n||(s=[s],i=[i]);const o=[];for(let h=0;h<s.length;h++){let n;switch(t){case"add":n=e(s[h]).plus(i[h]);break;case"mul":n=e(s[h]).times(i[h]);break;case"sub":n=e(s[h]).minus(i[h]);break;case"div":n=e(s[h]).dividedBy(i[h]);break;default:throw new Error("Invalid operation")}o.push(n)}return o},n=({fast:s,slow:i})=>{let t=Math.min(s.length,i.length);for(;s.length>t;)s.shift();for(;i.length>t;)i.shift();let e=null,h=null,n=t-1;for(;n>=0&&null===e;)s[n].isLessThan(i[n])&&n>0&&s[n-1].isGreaterThanOrEqualTo(i[n-1])?(e="down",h=n):s[n].isGreaterThan(i[n])&&n>0&&s[n-1].isLessThanOrEqualTo(i[n-1])&&(e="up",h=n),n--;return null===e?{crossInterval:null,crossType:null}:{crossInterval:h<t-1?t-1-h:0,crossType:e}};class o{constructor(s,i,e=12,h=26,n=9){this.BigNumber=s,this.fastLine=e,this.slowLine=h,this.signalLine=n,this.data=i,this.ema12=new t(s,i,e),this.ema26=new t(s,i,h),this.updateDiffAndDea()}updateDiffAndDea(){const s=this.ema12.get(),i=this.ema26.get();this.diff=h(s,i,"sub",this.BigNumber),this.dea=new t(this.BigNumber,this.diff,this.signalLine),this.deaResult=this.dea.get(),this.histogram=h(this.BigNumber(2),h(this.diff,this.deaResult,"sub",this.BigNumber),"mul",this.BigNumber);const{crossType:e,crossInterval:o}=n({fast:this.diff,slow:this.deaResult});this.crossType=e,this.crossInterval=o}add(s){this.ema12.add(s),this.ema26.add(s),this.updateDiffAndDea()}update(s){this.ema12.update(s),this.ema26.update(s),this.updateDiffAndDea()}get(){return{diff:this.diff,dea:this.deaResult,histogram:this.histogram,crossType:this.crossType,crossInterval:this.crossInterval}}}const l=(s,i)=>{let{upper:t,lower:e,mid:h}=i;t=t[t.length-1],e=e[e.length-1],h=h[h.length-1];const n=t.minus(e);return s.minus(e).dividedBy(n).times(100)};class r{constructor(s,i,t=20,h=2){this.BigNumber=s,this.size=t,this.times=s(h),this.data=i,this.avg=new e(s,i,t),this.sd=this.calculateDeviation(),this.updateBands()}calculateDeviation(){const s=this.BigNumber(0),i=this.data.length,t=this.avg.get(),e=[];let h,n,o=this.size-1;for(;o<i;o++){for(n=s,h=o-this.size+1;h<=o;h++)n=n.plus(this.data[h].minus(t[o]).pow(2));e[o]=n.dividedBy(this.size).sqrt()}return e}updateBands(){const s=this.avg.get(),i=this.sd,t=h(i,this.times,"mul",this.BigNumber);this.upper=h(s,t,"add",this.BigNumber),this.mid=s,this.lower=h(s,t,"sub",this.BigNumber)}add(s){this.data.push(s),this.avg.add(s),this.sd=this.calculateDeviation(),this.updateBands()}update(s){this.data[this.data.length-1]=s,this.avg.update(s),this.sd=this.calculateDeviation(),this.updateBands()}get(){const s=this.data[this.data.length-1],i=l(s,{upper:this.upper,mid:this.mid,lower:this.lower});return{upper:this.upper,mid:this.mid,lower:this.lower,loc:i}}}class a{constructor(s,i,t=14){this.BigNumber=s,this.ohlcv=i,this.period=t,this.calculateInitialValues()}calculateInitialValues(){let{high:s,low:i,close:t}=this.ohlcv;const e=this.BigNumber(0),h=this.BigNumber(100),n=s.length;this.plusDM=[],this.minusDM=[],this.tr=[],this.emaPlusDM=[],this.emaMinusDM=[],this.emaTR=[],this.diPlus=[],this.diMinus=[],this.dx=[],this.adx=[];for(let h=1;h<n;h++){const n=s[h].minus(s[h-1]),o=i[h-1].minus(i[h]),l=n.isGreaterThan(o)&&n.isGreaterThan(0)?n:e,r=o.isGreaterThan(n)&&o.isGreaterThan(0)?o:e,a=this.BigNumber.max(s[h].minus(i[h]),s[h].minus(t[h-1]).abs(),i[h].minus(t[h-1]).abs());this.plusDM.push(l),this.minusDM.push(r),this.tr.push(a)}for(let s=this.period;s<n;s++){const i=this.sum(this.plusDM.slice(s-this.period,s)).dividedBy(this.period),t=this.sum(this.minusDM.slice(s-this.period,s)).dividedBy(this.period),e=this.sum(this.tr.slice(s-this.period,s)).dividedBy(this.period);this.emaPlusDM.push(i),this.emaMinusDM.push(t),this.emaTR.push(e)}for(let s=0;s<this.emaPlusDM.length;s++){const i=h.times(this.emaPlusDM[s].dividedBy(this.emaTR[s])),t=h.times(this.emaMinusDM[s].dividedBy(this.emaTR[s]));this.diPlus.push(i),this.diMinus.push(t)}for(let s=this.period;s<this.emaPlusDM.length;s++){const i=this.sum(this.diPlus.slice(s-this.period+1,s+1)),t=this.sum(this.diMinus.slice(s-this.period+1,s+1)),e=h.times(i.minus(t).abs().div(i.plus(t)));this.dx.push(e)}const o=this.dx.filter((s=>!isNaN(s)));if(o.length>=this.period-1){const s=this.sum(o.slice(0,this.period-1)).div(this.period-1);this.adx.push(s);for(let s=this.period-1;s<o.length;s++){const i=this.adx[s-this.period+1].times(this.period-1).plus(o[s]).div(this.period);this.adx.push(i)}}}sum(s){return s.reduce(((s,i)=>s.plus(i)),this.BigNumber(0))}add(s){this.ohlcv.high.push(s.high),this.ohlcv.low.push(s.low),this.ohlcv.close.push(s.close),this.calculateInitialValues()}update(s){const i=this.ohlcv.high.length-1;this.ohlcv.high[i]=s.high,this.ohlcv.low[i]=s.low,this.ohlcv.close[i]=s.close,this.calculateInitialValues()}get(){return{adx:this.adx,diMinus:this.diMinus,diPlus:this.diPlus}}}class u{constructor(s,i,t=14){this.BigNumber=s,this.period=t,this.high=i.high,this.low=i.low,this.close=i.close,this.volume=i.volume,this.zero=s(0),this.hundred=s(100),this.one=s(1),this.typicalPrices=[],this.rawMoneyFlows=[],this.positiveMoneyFlows=[],this.negativeMoneyFlows=[],this.moneyFlowRatios=[],this.moneyFlowIndexes=[],this.calculateInitialMFI()}calculateInitialMFI(){for(let s=0;s<this.close.length;s++){const i=this.high[s].plus(this.low[s]).plus(this.close[s]).dividedBy(3),t=i.times(this.volume[s]);this.typicalPrices.push(i),this.rawMoneyFlows.push(t)}for(let s=1;s<this.typicalPrices.length;s++)this.typicalPrices[s].isGreaterThan(this.typicalPrices[s-1])?(this.positiveMoneyFlows.push(this.rawMoneyFlows[s]),this.negativeMoneyFlows.push(this.zero)):this.typicalPrices[s].isLessThan(this.typicalPrices[s-1])?(this.positiveMoneyFlows.push(this.zero),this.negativeMoneyFlows.push(this.rawMoneyFlows[s])):(this.positiveMoneyFlows.push(this.zero),this.negativeMoneyFlows.push(this.zero));for(let s=this.period;s<=this.positiveMoneyFlows.length;s++){const i=this.positiveMoneyFlows.slice(s-this.period,s),t=this.negativeMoneyFlows.slice(s-this.period,s),e=i.reduce(((s,i)=>s.plus(i)),this.zero),h=t.reduce(((s,i)=>s.plus(i)),this.zero),n=e.dividedBy(h);this.moneyFlowRatios.push(n)}for(let s=0;s<this.moneyFlowRatios.length;s++){const i=this.hundred.minus(this.hundred.dividedBy(this.one.plus(this.moneyFlowRatios[s])));this.moneyFlowIndexes.push(i)}}add(s){this.high.push(s.high),this.low.push(s.low),this.close.push(s.close),this.volume.push(s.volume);const i=s.high.plus(s.low).plus(s.close).dividedBy(3),t=i.times(s.volume);if(this.typicalPrices.push(i),this.rawMoneyFlows.push(t),this.typicalPrices.length>1){const s=this.typicalPrices[this.typicalPrices.length-2];if(i.isGreaterThan(s)?(this.positiveMoneyFlows.push(t),this.negativeMoneyFlows.push(this.zero)):i.isLessThan(s)?(this.positiveMoneyFlows.push(this.zero),this.negativeMoneyFlows.push(t)):(this.positiveMoneyFlows.push(this.zero),this.negativeMoneyFlows.push(this.zero)),this.positiveMoneyFlows.length>this.period){const s=this.positiveMoneyFlows.slice(-this.period),i=this.negativeMoneyFlows.slice(-this.period),t=s.reduce(((s,i)=>s.plus(i)),this.zero),e=i.reduce(((s,i)=>s.plus(i)),this.zero),h=t.dividedBy(e),n=this.hundred.minus(this.hundred.dividedBy(this.one.plus(h)));this.moneyFlowIndexes.push(n),this.moneyFlowIndexes.length>this.period&&this.moneyFlowIndexes.shift()}}}update(s){if(this.high.length>0&&this.low.length>0&&this.close.length>0&&this.volume.length>0){this.high[this.high.length-1]=s.high,this.low[this.low.length-1]=s.low,this.close[this.close.length-1]=s.close,this.volume[this.volume.length-1]=s.volume;const i=s.high.plus(s.low).plus(s.close).dividedBy(3),t=i.times(s.volume);this.typicalPrices[this.typicalPrices.length-1]=i,this.rawMoneyFlows[this.rawMoneyFlows.length-1]=t;const e=this.typicalPrices[this.typicalPrices.length-2];if(i.isGreaterThan(e)?(this.positiveMoneyFlows[this.positiveMoneyFlows.length-1]=t,this.negativeMoneyFlows[this.negativeMoneyFlows.length-1]=this.zero):i.isLessThan(e)?(this.positiveMoneyFlows[this.positiveMoneyFlows.length-1]=this.zero,this.negativeMoneyFlows[this.negativeMoneyFlows.length-1]=t):(this.positiveMoneyFlows[this.positiveMoneyFlows.length-1]=this.zero,this.negativeMoneyFlows[this.negativeMoneyFlows.length-1]=this.zero),this.positiveMoneyFlows.length>=this.period){const s=this.positiveMoneyFlows.slice(-this.period),i=this.negativeMoneyFlows.slice(-this.period),t=s.reduce(((s,i)=>s.plus(i)),this.zero),e=i.reduce(((s,i)=>s.plus(i)),this.zero),h=t.dividedBy(e),n=this.hundred.minus(this.hundred.dividedBy(this.one.plus(h)));this.moneyFlowIndexes[this.moneyFlowIndexes.length-1]=n}}}get(){return this.moneyFlowIndexes}}class d{constructor(s,i,e=14,h=14){this.BigNumber=s,this.period=e,this.emaPeriod=h,this.data=i,this.zero=s(0),this.hundred=s(100),this.one=s(1),this.rsi=[],this.pl=i.slice(0,e),i.length>=e&&this.calculateInitialRSI(),this.rsiEma=new t(s,this.rsi,h),this.updateCross()}calculateInitialRSI(){for(let s=this.period,i=this.zero,t=this.zero;s<this.data.length;s++,i=this.zero,t=this.zero){this.pl.push(this.data[s]);for(let s=1;s<this.pl.length;s++){const e=this.BigNumber(this.pl[s]),h=this.BigNumber(this.pl[s-1]);e.minus(h).isLessThan(this.zero)?t=t.plus(e.minus(h).abs()):i=i.plus(e.minus(h))}const e=i.dividedBy(this.period),h=t.dividedBy(this.period),n=h.isEqualTo(this.zero)?this.zero:e.dividedBy(h);this.rsi.push(this.hundred.minus(this.hundred.dividedBy(this.one.plus(n)))),this.pl.splice(0,1)}}updateCross(){const s=this.rsiEma.get(),{crossType:i,crossInterval:t}=n({fast:this.rsi,slow:s});this.crossType=i,this.crossInterval=t}add(s){this.data.push(s);const i=this.BigNumber(s),t=this.BigNumber(this.data[this.data.length-2]);let e=this.zero,h=this.zero;i.minus(t).isLessThan(this.zero)?h=h.plus(i.minus(t).abs()):e=e.plus(i.minus(t));const n=e.dividedBy(this.period),o=h.dividedBy(this.period),l=o.isEqualTo(this.zero)?this.zero:n.dividedBy(o);this.rsi.push(this.hundred.minus(this.hundred.dividedBy(this.one.plus(l)))),this.rsi.length>this.period&&this.rsi.shift(),this.rsiEma.add(this.rsi[this.rsi.length-1]),this.updateCross()}update(s){if(this.data.length>0){this.data[this.data.length-1]=s;const i=this.BigNumber(s),t=this.BigNumber(this.data[this.data.length-2]);let e=this.zero,h=this.zero;i.minus(t).isLessThan(this.zero)?h=h.plus(i.minus(t).abs()):e=e.plus(i.minus(t));const n=e.dividedBy(this.period),o=h.dividedBy(this.period),l=o.isEqualTo(this.zero)?this.zero:n.dividedBy(o);this.rsi[this.rsi.length-1]=this.hundred.minus(this.hundred.dividedBy(this.one.plus(l))),this.rsiEma.update(this.rsi[this.rsi.length-1]),this.updateCross()}}get(){return{rsi:this.rsi,rsiEma:this.rsiEma.get(),crossType:this.crossType,crossInterval:this.crossInterval}}}class c{constructor(s,i,t=14,e=3,h=3){this.BigNumber=s,this.rsi=i,this.kPeriods=t,this.kSlowingPeriods=e,this.dPeriods=h,this.updateValues()}updateValues(){if(this.rsi.length<this.kPeriods)return this.K=[],this.D=[],this.crossType=null,void(this.crossInterval=null);const s=this.BigNumber.max(this.kPeriods,this.kSlowingPeriods,this.dPeriods).toNumber(),i=[];for(let t=s;t<this.rsi.length;t++){const e=this.rsi.slice(t-s,t+1),h=this.BigNumber.min(...e),n=this.BigNumber.max(...e),o=this.rsi[t].minus(h).dividedBy(n.minus(h)).times(100);i.push(o)}this.K=new t(this.BigNumber,i,this.kSlowingPeriods).get(),this.D=new t(this.BigNumber,this.K,this.dPeriods).get();const{crossType:e,crossInterval:h}=n({fast:this.D,slow:this.K});this.crossType=e,this.crossInterval=h}add(s){this.rsi.push(s),this.updateValues()}update(s){this.rsi[this.rsi.length-1]=s,this.updateValues()}get(){return{K:this.K,D:this.D,crossType:this.crossType,crossInterval:this.crossInterval}}}class p{constructor({open:s,high:i,low:t,close:e}){this.open=s,this.high=i,this.low=t,this.close=e}get(){if(![this.open,this.high,this.low,this.close].every((s=>Array.isArray(s)&&s.length>1)))return{pattern:"",name:"",score:0};const s=this.open.length-2,i=this.open.length-1,t=Number(this.open[s]),e=Number(this.high[s]),h=Number(this.low[s]),n=Number(this.close[s]),o=Number(this.open[i]),l=Number(this.high[i]),r=Number(this.low[i]),a=Number(this.close[i]),u={bullish:[{name:"Engulfing",condition:r<h&&l>e&&a>o,score:2},{name:"Piercing Line",condition:a>n&&o<t&&a>(t+n)/2,score:1},{name:"Morning Star",condition:a>n&&o<t&&n<t,score:2},{name:"Harami",condition:a<t&&o>n&&a<n&&o>t,score:1},{name:"Doji",condition:Math.abs(a-o)<.01*a,score:0},{name:"Marubozu",condition:Math.abs(a-o)>.99*a,score:3},{name:"Belt Hold",condition:o>t&&a===l&&n===h,score:1},{name:"Kicker",condition:o>n&&a>o,score:2}],bearish:[{name:"Engulfing",condition:l>e&&r<h&&a<o,score:-2},{name:"Dark Cloud Cover",condition:a<n&&o>t&&a<(t+n)/2,score:-1},{name:"Evening Star",condition:a<n&&o>t&&n>t,score:-2},{name:"Harami",condition:a>t&&o<n&&a>n&&o<t,score:-1},{name:"Doji",condition:Math.abs(a-o)<.01*a,score:0},{name:"Marubozu",condition:Math.abs(a-o)>.99*a,score:-3},{name:"Belt Hold",condition:o<t&&a===r&&n===e,score:-1},{name:"Kicker",condition:o<n&&a<o,score:-2}]};for(const s of["bullish","bearish"])for(const{name:i,condition:t,score:e}of u[s])if(t)return{pattern:s,name:i,score:e};return{pattern:"",name:"",score:0}}add({open:s,high:i,low:t,close:e}){this.open.push(s),this.high.push(i),this.low.push(t),this.close.push(e)}update({open:s,high:i,low:t,close:e}){const h=this.open.length-1;this.open[h]=s,this.high[h]=i,this.low[h]=t,this.close[h]=e}}class g{constructor(s,i){this.BigNumber=s,this.ohlcv=i,this.TENKAN_SEN_PERIOD=9,this.KIJUN_SEN_PERIOD=26,this.SENKOU_SPAN_B_PERIOD=52,this.SENKOU_SPAN_A_PERIOD=Math.round((this.TENKAN_SEN_PERIOD+this.KIJUN_SEN_PERIOD)/2),this.updateLines()}updateLines(){const{high:s,low:i,close:t}=this.ohlcv;this.tenkanSen=this.calculateAverage(s,i,this.TENKAN_SEN_PERIOD),this.kijunSen=this.calculateAverage(s,i,this.KIJUN_SEN_PERIOD),this.senkouSpanA=this.tenkanSen.map(((s,i)=>i<this.kijunSen.length?s.plus(this.kijunSen[i]).dividedBy(2):null)).filter((s=>null!==s)),this.senkouSpanB=this.calculateAverage(s,i,this.SENKOU_SPAN_B_PERIOD),this.chikouSpan=t.slice(0,-this.KIJUN_SEN_PERIOD);const e=this.KIJUN_SEN_PERIOD;this.tenkanSen=this.tenkanSen.slice(e),this.kijunSen=this.kijunSen.slice(e),this.senkouSpanA=this.senkouSpanA.slice(e-this.KIJUN_SEN_PERIOD),this.senkouSpanB=this.senkouSpanB.slice(e-this.KIJUN_SEN_PERIOD);const h=t.slice(-this.tenkanSen.length);this.spanACross=n({fast:h,slow:this.senkouSpanA}),this.spanBCross=n({fast:h,slow:this.senkouSpanB}),this.baseCross=n({fast:this.tenkanSen,slow:this.kijunSen})}add(s){this.ohlcv.high.push(s.high),this.ohlcv.low.push(s.low),this.ohlcv.close.push(s.close),this.updateLines()}update(s){const i=this.ohlcv.high.length-1;this.ohlcv.high[i]=s.high,this.ohlcv.low[i]=s.low,this.ohlcv.close[i]=s.close,this.updateLines()}get(){return{conversionLine:this.tenkanSen,baseLine:this.kijunSen,leadingSpanA:this.senkouSpanA,leadingSpanB:this.senkouSpanB,laggingSpan:this.chikouSpan,crosses:{spanACross:this.spanACross,spanBCross:this.spanBCross,baseCross:this.baseCross}}}calculateAverage(s,i,t){return s.slice(t-1).map(((e,h)=>{const n=s.slice(h,h+t),o=i.slice(h,h+t);return this.BigNumber.maximum(...n).plus(this.BigNumber.minimum(...o)).dividedBy(2)}))}calculateSenkouSpanA(s,i){const t=[];for(let e=0;e<s.length;e++)t.push(s[e].plus(i[e]).dividedBy(2));return t}calculateSenkouSpanB(s,i,t){const e=[];for(let h=t-1;h<s.length;h++){const n=s.slice(h-t+1,h+1),o=i.slice(h-t+1,h+1),l=this.BigNumber.maximum(...n),r=this.BigNumber.minimum(...o);e.push(l.plus(r).dividedBy(2))}return e}calculateChikouSpan(s,i){return s.slice(0,s.length-i)}}class m{constructor(s){this.BigNumber=s,this.EMA=this.EMA.bind(this),this.MA=this.MA.bind(this),this.MACD=this.MACD.bind(this),this.BollingerBands=this.BollingerBands.bind(this),this.IchimokuCloud=this.IchimokuCloud.bind(this),this.ADX=this.ADX.bind(this),this.MFI=this.MFI.bind(this),this.RSI=this.RSI.bind(this),this.STOCHASTIC_RSI=this.STOCHASTIC_RSI.bind(this),this.bollingerBandsLocation=this.bollingerBandsLocation.bind(this),this.findLastCross=this.findLastCross.bind(this),this.getMomentum=this.getMomentum.bind(this)}EMA(s,i){return new t(this.BigNumber,s,i)}MA(s,i){return new e(this.BigNumber,s,i)}MACD(s,i,t,e){return new o(this.BigNumber,s,i,t,e)}BollingerBands(s,i,t){return new r(this.BigNumber,s,i,t)}IchimokuCloud(s){return new g(this.BigNumber,s)}ADX(s,i){return new a(this.BigNumber,s,i)}MFI(s,i){return new u(this.BigNumber,s,i)}RSI(s,i,t){return new d(this.BigNumber,s,i,t)}STOCHASTIC_RSI(s,i,t,e){return new c(this.BigNumber,s,i,t,e)}bollingerBandsLocation(s,i){return l(s,i)}findLastCross({fast:s,slow:i}){return n({fast:s,slow:i})}getMomentum({data:s,close:i,fast:t,slow:e}){return(({BigNumber:s,close:i,fast:t,slow:e})=>{const h=t[t.length-1],n=e[e.length-1],o=i[i.length-1];return o.isLessThan(h)||o.isLessThan(n)?s(0):h.minus(n).dividedBy(n).multipliedBy(100)})({BigNumber:this.BigNumber,data:s,close:i,fast:t,slow:e})}getCandlestickPattern(s){return new p(s)}}})(),PrecisionTradingIndicators=i})();