var PrecisionTradingIndicators;(()=>{"use strict";var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};(()=>{e.r(t),e.d(t,{default:()=>l});const s=(e,t,s)=>{const i=e(2/(s+1)),n=t.length,r=[];if(i.isGreaterThan(1))return Array(n);if(i.isEqualTo(1))return[...t];let o=0,l=0;for(;l<n;l++){const e=t[l];if("object"==typeof e){r[l]=e,o=e,l++;break}}if(Array.isArray(i))for(;l<n;l++){const e=t[l];"object"==typeof e&&"object"==typeof i[l]?o=r[l]=i[l].multipliedBy(e).plus(i[l].minus(1).multipliedBy(o)):r[l]=r[l-1]}else{const s=e(1).minus(i);for(;l<n;l++){const e=t[l];o="object"==typeof e?i.multipliedBy(e).plus(s.multipliedBy(o)):r[l-1],r[l]=o}}return r},i=(e,t,s)=>{const i=t.length,n=t.map((t=>e(t)));if(!s)return n.reduce(((e,t)=>e.plus(t))).dividedBy(i);if(s<=1)return n.slice();if(s>i)return Array(i);const r=[];let o=e(0);for(let e=0;e<i;e++){const t=n[e];if("object"==typeof t&&(o=o.plus(t)),e>=s){const t=n[e-s];"object"==typeof t&&(o=o.minus(t))}e>=s-1&&(r[e]=o.dividedBy(s))}return r},n=(e,t,s,i)=>{const n=Array.isArray(e),r=Array.isArray(t);if(n&&r&&e.length!==t.length)throw new Error("Array lengths must be the same");!n&&r&&(e=Array(t.length).fill(e)),n&&!r&&(t=Array(e.length).fill(t)),n||r||(e=[e],t=[t]);const o=[];for(let n=0;n<e.length;n++){let r;switch(s){case"add":r=i(e[n]).plus(t[n]);break;case"mul":r=i(e[n]).times(t[n]);break;case"sub":r=i(e[n]).minus(t[n]);break;case"div":r=i(e[n]).dividedBy(t[n]);break;default:throw new Error("Invalid operation")}o.push(r)}return o},r=({fast:e,slow:t})=>{const s=e.length;let i=null,n=null,r=s-1;for(;r>=0&&null===i;)e[r].isLessThan(t[r])&&r>0&&e[r-1].isGreaterThanOrEqualTo(t[r-1])?(i="down",n=r):e[r].isGreaterThan(t[r])&&r>0&&e[r-1].isLessThanOrEqualTo(t[r-1])&&(i="up",n=r),r--;return null===i?{crossInterval:null,crossType:null}:{crossInterval:n<s-1?s-1-n:0,crossType:i}},o=(e,t)=>{let{upper:s,lower:i,mid:n}=t;s=s[s.length-1],i=i[i.length-1],n=n[n.length-1];const r=s.minus(i);return e.minus(i).dividedBy(r).times(100)};class l{constructor(e){this.BigNumber=e,this.EMA=this.EMA.bind(this),this.MA=this.MA.bind(this),this.MACD=this.MACD.bind(this),this.BOLLINGER_BANDS=this.BOLLINGER_BANDS.bind(this),this.ADX=this.ADX.bind(this),this.MFI=this.MFI.bind(this),this.RSI=this.RSI.bind(this),this.STOCHASTIC_RSI=this.STOCHASTIC_RSI.bind(this),this.bollingerBandsLocation=this.bollingerBandsLocation.bind(this),this.getTrend=this.getTrend.bind(this),this.findLastCross=this.findLastCross.bind(this),this.getMomentum=this.getMomentum.bind(this)}EMA(e,t){return s(this.BigNumber,e,t)}MA(e,t){return i(this.BigNumber,e,t)}MACD(e,t,i,o){return((e,t,i=12,o=26,l=9)=>{const u=s(e,t,i),a=s(e,t,o),d=n(u,a,"sub",e),h=s(e,d,l),c=n(e(2),n(d,h,"sub",e),"mul",e),{crossType:m,crossInterval:p}=r({fast:d,slow:h});return{diff:d,dea:h,histogram:c,crossType:m,crossInterval:p}})(this.BigNumber,e,t,i,o)}BOLLINGER_BANDS(e,t,s){return((e,t,s=20,r=2)=>{r=e(r);const l=i(e,t,s),u=((e,t,s)=>{const n=e(0),r=t.length,o=i(e,t,s),l=[];let u,a,d=s-1;for(;d<r;d++){for(a=n,u=d-s+1;u<=d;u++)a=a.plus(t[u].minus(o[d]).pow(2));l[d]=a.dividedBy(s).sqrt()}return l})(e,t,s),a=n(u,r,"mul",e);let d=n(l,a,"add",e),h=l,c=n(l,a,"sub",e);const m=t[t.length-1];return{upper:d,mid:h,lower:c,loc:o(m,{upper:d,mid:h,lower:c})}})(this.BigNumber,e,t,s)}ADX(e,t){return((e,t,s=14)=>{let{high:i,low:n,close:r}=t;const o=e(0),l=e(100),u=i.length,a=e=>e.reduce(((e,t)=>e.plus(t)),o),d=[],h=[],c=[],m=[],p=[],b=[],g=[],f=[],y=[],B=[];for(let t=1;t<u;t++){const l=i[t].minus(i[t-1]),u=n[t-1].minus(n[t]),g=l.isGreaterThan(u)&&l.isGreaterThan(0)?l:o,f=u.isGreaterThan(l)&&u.isGreaterThan(0)?u:o,y=e.max(i[t].minus(n[t]),i[t].minus(r[t-1]).abs(),n[t].minus(r[t-1]).abs());if(d.push(g),h.push(f),c.push(y),t>=s){const e=a(d.slice(t-s,t)).dividedBy(s),i=a(h.slice(t-s,t)).dividedBy(s),n=a(c.slice(t-s,t)).dividedBy(s);m.push(e),p.push(i),b.push(n)}}for(let e=0;e<m.length;e++){const t=l.times(m[e].dividedBy(b[e])),s=l.times(p[e].dividedBy(b[e]));g.push(t),f.push(s)}for(let e=s;e<m.length;e++){const t=a(g.slice(e-s+1,e+1)),i=a(f.slice(e-s+1,e+1)),n=l.times(t.minus(i).abs().div(t.plus(i)));y.push(n)}const v=y.filter((e=>!isNaN(e)));if(v.length>=s-1){const e=a(v.slice(0,s-1)).div(s-1);B.push(e);for(let e=s-1;e<v.length;e++){const t=B[e-s+1].times(s-1).plus(v[e]).div(s);B.push(t)}}return{adx:B,diMinus:f,diPlus:g}})(this.BigNumber,e,t)}MFI(e,t){return((e,t,s=14)=>{const{high:i,low:n,close:r,volume:o}=t,l=e(0),u=e(100),a=e(1),d=[],h=[],c=[],m=[],p=[],b=[];for(let e=0;e<r.length;e++){const t=i[e].plus(n[e]).plus(r[e]).dividedBy(3),s=t.times(o[e]);d.push(t),h.push(s)}for(let e=1;e<d.length;e++)d[e].isGreaterThan(d[e-1])?(c.push(h[e]),m.push(l)):d[e].isLessThan(d[e-1])?(c.push(l),m.push(h[e])):(c.push(l),m.push(l));for(let e=s;e<=c.length;e++){const t=c.slice(e-s,e),i=m.slice(e-s,e),n=t.reduce(((e,t)=>e.plus(t)),l),r=i.reduce(((e,t)=>e.plus(t)),l),o=n.dividedBy(r);p.push(o)}for(let e=0;e<p.length;e++){const t=u.minus(u.dividedBy(a.plus(p[e])));b.push(t)}return b})(this.BigNumber,e,t)}RSI(e,t){return((e,t,s=14)=>{if(t.length<s)return[];let i=[],n=t.slice(0,s);const r=e(0),o=e(100),l=e(1);for(let u=s,a=r,d=r;u<t.length;u++,a=r,d=r){n.push(t[u]);for(let t=1;t<n.length;t++){const s=e(n[t]),i=e(n[t-1]);s.minus(i).isLessThan(r)?d=d.plus(s.minus(i).abs()):a=a.plus(s.minus(i))}const h=a.dividedBy(s),c=d.dividedBy(s),m=c.isEqualTo(r)?r:h.dividedBy(c),p=o.minus(o.dividedBy(l.plus(m)));i.push(p),n.splice(0,1)}return i})(this.BigNumber,e,t)}STOCHASTIC_RSI(e,t,i,n){return((e,t,i=14,n=3,o=3)=>{if(t.length<i)return[];const l=e.max(i,n,o),u=[];for(let s=l.toNumber();s<t.length;s++){const i=t.slice(s-l.toNumber(),s+1),n=e.min(...i),r=e.max(...i),o=t[s].minus(n).dividedBy(r.minus(n)).times(100);u.push(o)}const a=s(e,u,n),d=s(e,a,o),{crossType:h,crossInterval:c}=r({fast:d,slow:a});return{K:a,D:d,crossType:h,crossInterval:c}})(this.BigNumber,e,t,i,n)}bollingerBandsLocation(e,t){return o(e,t)}getTrend(e,t){return((e,t,s=24)=>{const i=t.length,n=Math.max(0,i-s),r=i-1;let o="";const l=e(0),u=e(.5),a=new Array(r-n);for(let e=n;e<r;e++)a[e-n]=t[e+1].minus(t[e]);const d=a.reduce(((e,t)=>e.plus(t)),l).dividedBy(a.length),h=a.reduce(((e,t)=>e.plus(t.minus(d).pow(2))),l).dividedBy(a.length-1).sqrt();return o=d.isGreaterThan(l)&&h.isGreaterThan(u.times(d))?"up":d.isLessThan(l)&&h.isGreaterThan(u.times(d.abs()))?"down":"neutral",o})(this.BigNumber,e,t)}findLastCross({fast:e,slow:t}){return r({fast:e,slow:t})}getMomentum({data:e,fast:t,slow:s,threshold:i}){return(({fast:e,slow:t})=>e[e.length-1].minus(t[t.length-1]))({data:e,fast:t,slow:s,threshold:i})}getCandlestickPattern(e){return(({open:e,high:t,low:s,close:i})=>{if(![e,t,s,i].every((e=>Array.isArray(e)&&e.length>1)))return{pattern:"",name:"",score:0};const n=e.length-2,r=e.length-1,o=e[n].toNumber(),l=t[n].toNumber(),u=s[n].toNumber(),a=i[n].toNumber(),d=e[r].toNumber(),h=t[r].toNumber(),c=s[r].toNumber(),m=i[r].toNumber(),p={bullish:[{name:"Engulfing",condition:c<u&&h>l,score:2},{name:"Piercing Line",condition:m>a&&d<o&&m>(o+a)/2,score:1},{name:"Morning Star",condition:m>a&&d<o&&a<o,score:2},{name:"Harami",condition:m<o&&d>a&&m<a&&d>o,score:1},{name:"Doji",condition:Math.abs(m-d)<.01*m,score:0},{name:"Marubozu",condition:Math.abs(m-d)>.99*m,score:3},{name:"Belt Hold",condition:d>o&&m===h&&a===u,score:1},{name:"Kicker",condition:d<o&&m<a&&m<d,score:2}],bearish:[{name:"Engulfing",condition:h>l&&c<u,score:-2},{name:"Dark Cloud Cover",condition:m<a&&d>o&&m<(o+a)/2,score:-1},{name:"Evening Star",condition:m<a&&d>o&&a<o,score:-2},{name:"Harami",condition:m>o&&d<a&&m>a&&d<o,score:-1},{name:"Doji",condition:Math.abs(m-d)<.01*m,score:0},{name:"Marubozu",condition:Math.abs(m-d)>.99*m,score:-3},{name:"Belt Hold",condition:d<o&&m===c&&a===l,score:-1},{name:"Kicker",condition:d>o&&m>a&&m>d,score:-2}]};for(const e of["bullish","bearish"])for(const{name:t,condition:s,score:i}of p[e])if(s)return{pattern:e,name:t,score:i};return{pattern:"",name:"",score:0}})(e)}}})(),PrecisionTradingIndicators=t})();